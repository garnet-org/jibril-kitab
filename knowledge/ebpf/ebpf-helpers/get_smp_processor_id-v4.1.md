---
icon: microchip
---

# get\_smp\_processor\_id

## Summary

The `get_smp_processor_id` helper function returns the ID of the CPU core on which the eBPF program is currently running. This can be useful for debugging, load balancing, or ensuring that certain operations are performed on specific cores.

## Kernel Code

```c
#include <linux/bpf.h>
#include <bpf/bpf_helpers.h>

SEC("socket")
int bpf_prog(struct __sk_buff *skb) {
    __u32 cpu_id = bpf_get_smp_processor_id();
    bpf_printk("Running on CPU: %u\n", cpu_id);
    return 0;
}

char LICENSE[] SEC("license") = "GPL";
```

**Summary**:

* The eBPF program retrieves the ID of the CPU core on which it is running using `bpf_get_smp_processor_id`.
* The CPU ID is printed to the BPF trace pipe using `bpf_printk`.

## Userland Code

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <bpf/bpf.h>
#include <bpf/libbpf.h>

#define PATH_TO_BPF_OBJ "my_bpf.o"

int load_bpf_program(const char *filename) {
    int fd = bpf_obj_get(filename);
    if (fd < 0) {
        perror("bpf_obj_get");
        return -1;
    }
    return fd;
}

int attach_program(int prog_fd, int sock_fd) {
    int ret = setsockopt(sock_fd, SOL_SOCKET, SO_ATTACH_BPF, &prog_fd, sizeof(prog_fd));
    if (ret < 0) {
        perror("setsockopt");
        return -1;
    }
    return 0;
}

int main(int argc, char **argv) {
    int prog_fd, sock_fd;
    struct bpf_object *obj;
    struct bpf_program *prog;

    // Load BPF object file
    obj = bpf_object__open(PATH_TO_BPF_OBJ);
    if (!obj) {
        perror("bpf_object__open");
        return 1;
    }

    // Load BPF programs and maps
    if (bpf_object__load(obj) < 0) {
        fprintf(stderr, "Failed to load BPF object\n");
        goto cleanup;
    }

    // Get file descriptor for the BPF program
    prog = bpf_object__find_program_by_name(obj, "bpf_prog");
    if (!prog) {
        fprintf(stderr, "Failed to find BPF program\n");
        goto cleanup;
    }
    prog_fd = bpf_program__fd(prog);
    if (prog_fd < 0) {
        fprintf(stderr, "Failed to get BPF program FD\n");
        goto cleanup;
    }

    // Create socket
    sock_fd = socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL));
    if (sock_fd < 0) {
        perror("socket");
        goto cleanup;
    }

    // Attach BPF program to socket
    if (attach_program(prog_fd, sock_fd) < 0) {
        fprintf(stderr, "Failed to attach BPF program\n");
        goto cleanup;
    }

    printf("Attached BPF program. Press Ctrl+C to exit.\n");
    getchar();

cleanup:
    close(sock_fd);
    bpf_object__close(obj);
    return 0;
}
```

**Summary**:

* The userland program loads the BPF object file using `bpf_object__open` and `bpf_object__load`.
* It retrieves the file descriptor for the BPF program using `bpf_program__fd`.
* A raw socket is created and the BPF program is attached to it using `setsockopt`.
* The program waits for user input to keep the BPF program running, allowing it to execute.
* Resources are cleaned up when the program exits.

## Conclusions

* The example demonstrates the use of the `get_smp_processor_id` helper function to retrieve the ID of the CPU core on which the eBPF program is running.
* The userland code uses full libbpf functions to load, attach programs, and manage resources without using the skeleton generated by `bpftool`.
* The output from `bpf_printk` can be viewed using `bpftool` by running `bpftool prog trace`.
